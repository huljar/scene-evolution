#include <scene-evolution/BoundingBoxManager.h>
#include <scene-evolution/util.h>

#include <OGRE/OgreMatrix3.h>

#include <QDir>
#include <QFile>
#include <QFileDialog>
#include <QMessageBox>
#include <QTextStream>

#include <iostream>

BoundingBoxManager::BoundingBoxManager(Ogre::SceneManager* sceneMgr, unsigned int currentSceneIdx, const QString& defaultSavePath)
    : mCurrentSceneIdx(currentSceneIdx)
    , mCurrentOBB(nullptr)
    , mFilePath(defaultSavePath)
    , mSceneMgr(sceneMgr)
    , mUnsavedChanges(false)
{
}

BoundingBoxManager::~BoundingBoxManager() {
    // TODO: destructor (and other constructors?)
    for(SceneBoxMap::iterator it = mSceneBoxMap.begin(); it != mSceneBoxMap.end(); ++it) {
        for(BoxSet::iterator jt = it->begin(); jt != it->end(); ++jt) {
            delete *jt;
        }
    }
}

OrientedBoundingBox* BoundingBoxManager::createBox(const Ogre::Vector3& center, const Ogre::Vector3& extents,
                                                   const Ogre::Quaternion& orientation, const QString& objectType) {
    OrientedBoundingBox* obb = new OrientedBoundingBox(mSceneMgr, center, extents, orientation, objectType);
    mSceneBoxMap[mCurrentSceneIdx].insert(obb);
    return obb;
}

void BoundingBoxManager::destroyBox(OrientedBoundingBox* box) {
    destroyBox(box, mCurrentSceneIdx);
}

void BoundingBoxManager::destroyBox(OrientedBoundingBox* box, unsigned int sceneIdx) {
    if(mSceneBoxMap.contains(sceneIdx))
        mSceneBoxMap[sceneIdx].remove(box);
    delete box;
}

bool BoundingBoxManager::loadFromFile(const QString& path) {
    return true;
}

bool BoundingBoxManager::saveToFile(const QString& path) {
    QFile file(path);
    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))
        return false;

    QTextStream out(&file);

    // Write header information
    out << "# This is an oriented bounding box collection for the scenes\n"
        << "# of an RGB-D dataset.\n"
        << "# Generated by Scene Evolution tool.\n";

    // Iterate over scenes
    for(SceneBoxMap::iterator it = mSceneBoxMap.begin(); it != mSceneBoxMap.end(); ++it) {
        // Write scene index
        out << "\nbegin scene " << it.key() << "\n";

        // Iterate over boxes
        for(BoxSet::iterator jt = it->begin(); jt != it->end(); ++jt) {
            // Gather box info
            Ogre::Vector3 c = (*jt)->getCenter();
            Ogre::Vector3 e = (*jt)->getExtents();
            Ogre::Quaternion o = (*jt)->getOrientation();
            QString t = (*jt)->getObjectType();

            // Write box info
            out << "\nbegin box\n"
                << "center " << c.x << " " << c.y << " " << c.z << "\n"
                << "extents " << e.x << " " << e.y << " " << e.z << "\n"
                << "orient " << o.w << " " << o.x << " " << o.y << " " << o.z << "\n"
                << "objtype " << t << "\n";
        }
    }

    file.close();

    mUnsavedChanges = false;

    return true;
}

void BoundingBoxManager::onDatasetChanging(DatasetChangingEventArgs& e) {
    if(mUnsavedChanges) {
        int ret = QMessageBox::warning(nullptr, tr("Scene Evolution"),
                                       tr("There are unsaved changes to the bounding boxes of the current dataset.\nDo you want to save your changes?"),
                                       QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);

        if(ret == QMessageBox::Save) {
            // Save all changes
            QString path = QFileDialog::getSaveFileName(nullptr, tr("Save File"), (mFilePath.isEmpty() ? QDir::homePath() : mFilePath),
                                                        tr("Oriented Bounding Box Collections (*.obbc)"));
            if(path.isEmpty()) {
                // If the file dialog is canceled, abort the window closing
                e.abort = true;
            }
            else {
                mFilePath = path;
                bool success = saveToFile(path);
                if(!success) {
                    QMessageBox::critical(nullptr, tr("Scene Evolution"), tr("An error occurred while saving the file."), QMessageBox::Ok, QMessageBox::Ok);
                    e.abort = true;
                }
            }
        }
        else if(ret == QMessageBox::Cancel) {
            // Indicate that the window should not be closed
            e.abort = true;
        }
    }
}

void BoundingBoxManager::onDatasetChanged(DatasetChangedEventArgs& e) {
    // TODO: clear map, set scene idx
}

void BoundingBoxManager::onSceneChanging(SceneChangingEventArgs& e) {
    // Check if there is an unfinalized box
    if(mCurrentOBB) {
        int ret = QMessageBox::warning(nullptr, tr("Scene Evolution"),
                                       tr("You have an unfinalized bounding box for the current scene.\nDo you want to finalize it (will be deleted otherwise)?"),
                                       QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel, QMessageBox::Yes);

        if(ret == QMessageBox::Yes) {
            onPushButtonFinalizeBoxClicked(false);
        }
        else if(ret == QMessageBox::No) {
            onPushButtonCancelBoxClicked(false);
        }
        else { // ret == Cancel
            e.abort = true;
        }
    }
    // TODO: perform this check also on window closing and on dataset changing
}

void BoundingBoxManager::onSceneChanged(SceneChangedEventArgs& e) {
    // Hide boxes of current scene
    if(mSceneBoxMap.contains(mCurrentSceneIdx)) {
        BoxSet& boxes = mSceneBoxMap[mCurrentSceneIdx];
        for(BoxSet::iterator it = boxes.begin(); it != boxes.end(); ++it) {
            (*it)->hide();
        }
    }

    // Change the scene
    mCurrentSceneIdx = e.sceneIdx;

    // Show boxes of new scene (if any already exist)
    if(mSceneBoxMap.contains(e.sceneIdx)) {
        BoxSet& boxes = mSceneBoxMap[e.sceneIdx];
        for(BoxSet::iterator it = boxes.begin(); it != boxes.end(); ++it) {
            (*it)->show();
        }
    }
}

void BoundingBoxManager::onMainWindowClosing(WindowClosingEventArgs& e) {
    if(mUnsavedChanges) {
        int ret = QMessageBox::warning(nullptr, tr("Scene Evolution"), tr("There are unsaved changes to the bounding boxes.\nDo you want to save your changes?"),
                                       QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel, QMessageBox::Save);

        if(ret == QMessageBox::Save) {
            // Save all changes
            QString path = QFileDialog::getSaveFileName(nullptr, tr("Save File"), (mFilePath.isEmpty() ? QDir::homePath() : mFilePath),
                                                        tr("Oriented Bounding Box Collections (*.obbc)"));
            if(path.isEmpty()) {
                // If the file dialog is canceled, abort the window closing
                e.abort = true;
            }
            else {
                mFilePath = path;
                bool success = saveToFile(path);
                if(!success) {
                    QMessageBox::critical(nullptr, tr("Scene Evolution"), tr("An error occurred while saving the file."), QMessageBox::Ok, QMessageBox::Ok);
                    e.abort = true;
                }
            }
        }
        else if(ret == QMessageBox::Cancel) {
            // Indicate that the window should not be closed
            e.abort = true;
        }
    }
}

void BoundingBoxManager::onPushButtonStartNewBoxClicked(bool checked) {
    Q_UNUSED(checked);

    std::cout << "New box" << std::endl;
    if(!mCurrentOBB) {
        Ogre::Matrix3 rot;
        rot.FromEulerAnglesXYZ(Ogre::Degree(Constants::InitialOBBEulerAngles.x), Ogre::Degree(Constants::InitialOBBEulerAngles.y), Ogre::Degree(Constants::InitialOBBEulerAngles.z));
        mCurrentOBB = createBox(Constants::InitialOBBCenter, Constants::InitialOBBExtents, Ogre::Quaternion(rot), Constants::OBBSupportedObjects.at(Constants::InitialOBBObjectIndex));
    }
}

void BoundingBoxManager::onBoundingBoxCenterValueChanged(double x, double y, double z) {
    std::cout << "Center changed: (" << x << ", " << y << ", " << z << ")" << std::endl;
    if(mCurrentOBB) {
        mCurrentOBB->setCenter(x, y, z);
    }
}

void BoundingBoxManager::onBoundingBoxExtentsValueChanged(double x, double y, double z) {
    std::cout << "Extents changed: (" << x << ", " << y << ", " << z << ")" << std::endl;
    if(mCurrentOBB) {
        mCurrentOBB->setExtents(x, y, z);
    }
}

void BoundingBoxManager::onBoundingBoxEulerAnglesValueChanged(double x, double y, double z) {
    std::cout << "Euler angles changed: (" << x << ", " << y << ", " << z << ")" << std::endl;
    if(mCurrentOBB) {
        Ogre::Matrix3 rot;
        rot.FromEulerAnglesXYZ(Ogre::Degree(x), Ogre::Degree(y), Ogre::Degree(z));
        mCurrentOBB->setOrientation(Ogre::Quaternion(rot));
    }
}

void BoundingBoxManager::onComboBoxBoundingBoxTypeCurrentIndexChanged(const QString& text) {
    std::cout << "Type changed: " << text.toStdString() << std::endl;
    if(mCurrentOBB) {
        mCurrentOBB->setObjectType(text);
    }
}

void BoundingBoxManager::onPushButtonFinalizeBoxClicked(bool checked) {
    Q_UNUSED(checked);

    std::cout << "Finalized box" << std::endl;
    if(mCurrentOBB) {
        mCurrentOBB->setActive(false);
        mCurrentOBB = nullptr;
    }

    mUnsavedChanges = true;
}

void BoundingBoxManager::onPushButtonCancelBoxClicked(bool checked) {
    Q_UNUSED(checked);

    std::cout << "Canceled box" << std::endl;
    if(mCurrentOBB) {
        destroyBox(mCurrentOBB);
        mCurrentOBB = nullptr;
    }
}
